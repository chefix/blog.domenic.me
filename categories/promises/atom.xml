<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: promises | Hidden Variables]]></title>
  <link href="https://blog.domenic.me/categories/promises/atom.xml" rel="self"/>
  <link href="https://blog.domenic.me/"/>
  <updated>2014-10-25T23:51:11-04:00</updated>
  <id>https://blog.domenic.me/</id>
  <author>
    <name><![CDATA[Domenic Denicola]]></name>
    <email><![CDATA[domenic@domenicdenicola.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Revealing Constructor Pattern]]></title>
    <link href="https://blog.domenic.me/the-revealing-constructor-pattern/"/>
    <updated>2014-02-13T19:00:00-05:00</updated>
    <id>https://blog.domenic.me/the-revealing-constructor-pattern</id>
    <content type="html"><![CDATA[<p>I want to document an interesting pattern we&rsquo;ve seen emerge in some recent web platform specs, including <a href="https://people.mozilla.org/%7Ejorendorff/es6-draft.html#sec-promise-objects">promises</a> and <a href="https://github.com/whatwg/streams">streams</a>. I&rsquo;m calling it the <strong>revealing constructor pattern</strong>.</p>

<h2 id="the-promises-example">The Promises Example</h2>

<p>Let&rsquo;s take the case of promises first, since that may be familiar. You can construct a new promise like so:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Use `resolve` to resolve `p`.</span>
    <span class="c1">// Use `reject` to reject `p`.</span>
<span class="p">});</span>
</code></pre></div>
<p>We see here that the <code>Promise</code> constructor takes a single function as its sole parameter (called the &ldquo;executor function&rdquo;). It then <em>immediately</em> calls that function with two arguments, <code>resolve</code> and <code>reject</code>. These arguments have the capability to manipulate the internal state of the newly-constructed <code>Promise</code> instance <code>p</code>.</p>

<p>I call this the revealing constructor pattern because the <code>Promise</code> constructor is <em>revealing</em> its internal capabilities, but only to the code that constructs the promise in question. The ability to resolve or reject the promise is only revealed to the constructing code, and is crucially <em>not</em> revealed to anyone <em>using</em> the promise. So if we hand off <code>p</code> to another consumer, say</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">doThingsWith</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
</code></pre></div>
<p>then we can be sure that this consumer cannot mess with any of the internals that were revealed to us by the constructor. This is as opposed to, for example, putting <code>resolve</code> and <code>reject</code> methods on <code>p</code>, which anyone could call. (And no, adding underscores to the beginning of your method names won&rsquo;t save you.)</p>

<h2 id="historical-origins">Historical Origins</h2>

<p>The first place anyone can remember seeing this pattern is <a href="http://msdn.microsoft.com/en-us/library/windows/apps/br211866.aspx">in the WinJS promise implementation</a>. Before that, promise libraries used an awkward concept called a &ldquo;deferred.&rdquo; You would do something like this:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">deferred</span> <span class="o">=</span> <span class="nx">Q</span><span class="p">.</span><span class="nx">defer</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">deferred</span><span class="p">.</span><span class="nx">promise</span><span class="p">;</span>

<span class="c1">// Use `deferred.resolve` to resolve `p`.</span>
<span class="c1">// Use `deferred.reject` to reject `p`.</span>

<span class="nx">doThingsWith</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
</code></pre></div>
<p>This was strange in a few ways, but most prominently, it was strange because you were constructing an object without using a constructor. This is generally an antipattern in JavaScript: we want to be able to clearly conceptualize the relationship between instances, constructor functions, and prototypes.</p>

<p>In contrast, with the revealing constructor pattern, we get our nice constructor invariants back. Things like:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">p</span> <span class="k">instanceof</span> <span class="nx">Promise</span><span class="p">;</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nx">Promise</span><span class="p">;</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="o">===</span> <span class="nx">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
</code></pre></div>
<p>These are all signs that you&rsquo;re dealing with a well-designed &ldquo;class&rdquo; in JavaScript, that will behave as you expect.</p>

<h2 id="the-streams-example">The Streams Example</h2>

<p>When putting together <a href="htwetps://github.com/whatwg/streams">the in-progress streams spec</a>, we of course drew a lot of inspiration from <a href="http://nodejs.org/api/stream.html">Node streams</a>. But Node streams do things kind of strangely, with regard to vending their capabilities.</p>

<p>To produce a Node stream representing a specific resource—which is somewhat analogous to producing a promise representing a specific asynchronous operation—you don&rsquo;t use the stream constructor. You don&rsquo;t even use something like the deferred pattern. Instead, you <em>subclass</em> the appropriate stream class. And then you overwrite certain underscore-prefixed methods!</p>

<p>So for a simplified example, here is how you would create a file reader stream using the Node APIs. I&rsquo;ll use ES6 class syntax for brevity, but that is just sugar over the usual ES5 incantations.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">class</span> <span class="nx">FileReaderStream</span> <span class="kr">extends</span> <span class="nx">Readable</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">filename</span> <span class="o">=</span> <span class="nx">filename</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">_read</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Use `this.filename` to eventually call `this.push(chunk)`</span>
    <span class="c1">// with some data from the file, or `this.push(null)` to close</span>
    <span class="c1">// the stream, or `this.emit(&quot;error&quot;, e)` with an error.</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">myNodeStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FileReaderStream</span><span class="p">(</span><span class="s2">&quot;/path/to/file.txt&quot;</span><span class="p">);</span>
</code></pre></div>
<p>There are two interesting actors here:</p>

<ul>
<li><code>_read</code>, a method not meant to be called by users directly, but instead called by the internals of the stream when it&rsquo;s time to read data from the underlying source.</li>
<li><code>push</code> and <code>emit(&quot;error&quot;, e)</code>, which have the capability to manipulate the stream&rsquo;s internal buffer and state machine. They too are not meant to be called by users directly, but instead only by implementers, inside their <code>_read</code> method (or perhaps inside the constructor).</li>
</ul>

<p>Interestingly, these are almost exactly analogous to the promise situation. <code>_read</code> is like the executor argment passed to the promise constructor, in that it consists of user code that does the actual work. And <code>push</code>/<code>emit</code> are capabilities, like <code>resolve</code>/<code>reject</code>, which can be used by the work-doing function to manipulate internal state.</p>

<p>In building the streams spec, we realized the Node pattern wasn&rsquo;t the way we wanted to go. Requiring subclassing for every stream instance is not ergonomic. Using underscore-prefixed methods as the extension point isn&rsquo;t realistic either. And letting any user access the capabilities involved is not tenable, in part because it means implementations can&rsquo;t build invariants around who has access to the internal buffer.</p>

<p>In contrast, the revealing constructor pattern works out really well. To create a file reader stream with whatwg/streams, you do something like</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">createFileReaderStream</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">ReadableStream</span><span class="p">({</span>
    <span class="nx">pull</span><span class="p">(</span><span class="nx">enqueue</span><span class="p">,</span> <span class="nx">close</span><span class="p">,</span> <span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Use `filename` to eventually call `enqueue(chunk)`</span>
      <span class="c1">// with some data from the file, or `close()` to</span>
      <span class="c1">// close the stream, or `error(e)` with an error.</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">myWhatwgStream</span> <span class="o">=</span> <span class="nx">createFileReaderStream</span><span class="p">(</span><span class="s2">&quot;/path/to/file.txt&quot;</span><span class="p">);</span>
</code></pre></div>
<p>Notice the difference in the external API exposed. If you pass <code>myNodeStream</code> to another function, that function can mess with the stream&rsquo;s internal state as much as it wants, calling <code>push</code>, emitting <code>&quot;error&quot;</code> events, or even (despite the underscore) calling <code>_read</code>. Whereas if you pass <code>myWhatwgStream</code> around, consumers will not be able to do any of those things: the integrity of its internal state will be preserved.</p>

<p>(Plus, no subclassing!)</p>

<h2 id="when-would-i-use-this?">When Would I Use This?</h2>

<p>I admit that that the revealing constructor pattern seems a bit unorthodox. The number of actors involved—viz. the constructor itself, the work-doing function to which capabilities are given, and the capability arguments—can be hard to get your head around, at least the first few times you see them.</p>

<p>That said, it is a pretty elegant solution to a tricky problem. You might not need this level of encapsulation in your home-grown code. And even more widespread libraries may be able to skate by, as Node does, with documentation strategies and an attitude of &ldquo;don&rsquo;t do anything dumb with the capabilities we leave lying around, or it&rsquo;ll break.&rdquo; But when writing platform-level libraries and abstractions, which need to maintain their integrity in the face of any environment, the revealing constructor pattern really proves its worth.</p>

<p>And besides, patterns become part of our vernacular. Many patterns that are commonplace today seemed just as strange when they are introduced as the revealing constructor pattern might to you now. After working with promises and streams for a while, you might encounter a situation where a revealing constructor is a natural fit for your library&rsquo;s needs. Who knows!</p>

<h2 id="postscript">Postscript</h2>

<p>If those examples weren&rsquo;t enough, here&rsquo;s one that you should be able to connect with: <a href="https://gist.github.com/domenic/9003334">an event emitter using the revealing constructor pattern</a>. This is an evolution of some of my <a href="https://github.com/domenic/pubit">earlier work</a> on event emitters with separate capabilities.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[You're Missing the Point of Promises]]></title>
    <link href="https://blog.domenic.me/youre-missing-the-point-of-promises/"/>
    <updated>2012-10-14T18:05:55-04:00</updated>
    <id>https://blog.domenic.me/youre-missing-the-point-of-promises</id>
    <content type="html"><![CDATA[<p><em>This post originally appeared <a href="https://gist.github.com/domenic/3889970">as a gist</a>. Since then, the development of
Promises/A+ has made its emphasis on the Promises/A spec seem somewhat outdated.</em></p>

<p><em>Contrary to some mistaken statements on the internet, the problems with jQuery&rsquo;s promises explained here are not fixed
in recent versions; as of 2.1 beta 1 they have all the same problems outlined here, and according to one jQuery core
team member, <a href="http://esdiscuss.org/topic/a-challenge-problem-for-promise-designers-was-re-futures#content-43">they will forever remain broken</a>, in the name of backward compatibility.</em></p>

<p><strong>Promises</strong> are a software abstraction that makes working with asynchronous operations much more pleasant. In the most
basic definition, your code will move from continuation-passing style:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">getTweetsFor</span><span class="p">(</span><span class="s2">&quot;domenic&quot;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">results</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// the rest of your code goes here.</span>
<span class="p">});</span>
</code></pre></div>
<p>to one where your functions return a value, called a <em>promise</em>, which represents the eventual results of that operation.</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">promiseForTweets</span> <span class="o">=</span> <span class="nx">getTweetsFor</span><span class="p">(</span><span class="s2">&quot;domenic&quot;</span><span class="p">);</span>
</code></pre></div>
<p>This is powerful since you can now treat these promises as first-class objects, passing them around, aggregating them,
and so on, instead of inserting dummy callbacks that tie together other callbacks in order to do the same.</p>

<p>I&rsquo;ve talked about how cool I think promises are <a href="http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript">at length</a>. This essay isn&rsquo;t about that. Instead, it&rsquo;s
about a disturbing trend I am seeing in recent JavaScript libraries that have added promise support: <em>they completely
miss the point of promises</em>.</p>

<h2 id="thenables-and-commonjs-promises/a">Thenables and CommonJS Promises/A</h2>

<p>When someone says &ldquo;promise&rdquo; in a JavaScript context, usually they mean—or at least <em>think</em> they
mean—<a href="http://wiki.commonjs.org/wiki/Promises/A">CommonJS Promises/A</a>. This is one of the smallest &ldquo;specs&rdquo; I&rsquo;ve seen. The meat of it is entirely about specifying
the behavior of a single function, <code>then</code>:</p>

<blockquote>
<p>A promise is defined as an object that has a function as the value for the property <code>then</code>:</p>

<p><code>then(fulfilledHandler, errorHandler, progressHandler)</code></p>

<p>Adds a <code>fulfilledHandler</code>, <code>errorHandler</code>, and <code>progressHandler</code> to be called for completion of a promise. The
<code>fulfilledHandler</code> is called when the promise is fulfilled. The <code>errorHandler</code> is called when a promise fails. The
<code>progressHandler</code> is called for progress events. All arguments are optional and non-function values are ignored. The
<code>progressHandler</code> is not only an optional argument, but progress events are purely optional. Promise implementors are
not required to ever call a <code>progressHandler</code> (the <code>progressHandler</code> may be ignored), this parameter exists so that
implementors may call it if they have progress events to report.</p>

<p>This function should return a new promise that is fulfilled when the given <code>fulfilledHandler</code> or <code>errorHandler</code>
callback is finished. This allows promise operations to be chained together. The value returned from the callback
handler is the fulfillment value for the returned promise. If the callback throws an error, the returned promise will
be moved to failed state.</p>
</blockquote>

<p>People mostly understand the first paragraph. It boils down to <em>callback aggregation</em>. You use <code>then</code> to attach
callbacks to a promise, whether for success or for errors (or even progress). When the promise transitions state—which
is out of scope of this very small spec!—your callbacks will be called. This is pretty useful, I guess.</p>

<p>What people don&rsquo;t seem to notice is the second paragraph. Which is a shame, since it&rsquo;s the most important one.</p>

<h2 id="what-is-the-point-of-promises?">What Is the Point of Promises?</h2>

<p>The thing is, promises are not <em>about</em> callback aggregation. That&rsquo;s a simple utility. Promises are about something
much deeper, namely providing a direct correspondence between synchronous functions and asynchronous functions.</p>

<p>What does this mean? Well, there are two very important aspects of synchronous functions:</p>

<ul>
<li>They <em>return values</em></li>
<li>They <em>throw exceptions</em></li>
</ul>

<p>Both of these are essentially about composition. That is, you can feed the return value of one function straight into
another, and keep doing this indefinitely. <em>More importantly</em>, if at any point that process fails, one function in the
composition chain can throw an exception, which then bypasses all further compositional layers until it comes into the
hands of someone who can handle it with a <code>catch</code>.</p>

<p>Now, in an asynchronous world, you can no longer return values: they simply aren&rsquo;t ready in time. Similarly, you can&rsquo;t
throw exceptions, because nobody&rsquo;s there to catch them. So we descend into the so-called &ldquo;callback hell,&rdquo; where
composition of return values involves nested callbacks, and composition of errors involves passing them up the chain
manually, and oh by the way you&rsquo;d better <em>never</em> throw an exception or else you&rsquo;ll need to introduce something crazy
like <a href="http://nodejs.org/api/domain.html">domains</a>.</p>

<p><em>The point of promises is to give us back functional composition and error bubbling in the async world.</em> They do this
by saying that your functions should return a promise, which can do one of two things:</p>

<ul>
<li>Become <em>fulfilled by a value</em></li>
<li>Become <em>rejected with an exception</em></li>
</ul>

<p>And, <em>if</em> you have a correctly implemented <code>then</code> function that follows Promises/A, then fulfillment and rejection will
compose just like their synchronous counterparts, with fulfillments flowing up a compositional chain, but being
interrupted at any time by a rejection that is only handled by someone who declares they are ready to handle it.</p>

<p>In other words, the following asynchronous code:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">getTweetsFor</span><span class="p">(</span><span class="s2">&quot;domenic&quot;</span><span class="p">)</span> <span class="c1">// promise-returning function</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">tweets</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">shortUrls</span> <span class="o">=</span> <span class="nx">parseTweetsForUrls</span><span class="p">(</span><span class="nx">tweets</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">mostRecentShortUrl</span> <span class="o">=</span> <span class="nx">shortUrls</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">return</span> <span class="nx">expandUrlUsingTwitterApi</span><span class="p">(</span><span class="nx">mostRecentShortUrl</span><span class="p">);</span> <span class="c1">// promise-returning function</span>
  <span class="p">})</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">httpGet</span><span class="p">)</span> <span class="c1">// promise-returning function</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">responseBody</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Most recent link text:&quot;</span><span class="p">,</span> <span class="nx">responseBody</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s2">&quot;Error with the twitterverse:&quot;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">);</span>
</code></pre></div>
<p>parallels<sup><a href="https://github.com/kriskowal/q/wiki/On-Exceptions">*</a></sup> the synchronous code:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="k">try</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">tweets</span> <span class="o">=</span> <span class="nx">getTweetsFor</span><span class="p">(</span><span class="s2">&quot;domenic&quot;</span><span class="p">);</span> <span class="c1">// blocking</span>
  <span class="kd">var</span> <span class="nx">shortUrls</span> <span class="o">=</span> <span class="nx">parseTweetsForUrls</span><span class="p">(</span><span class="nx">tweets</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">mostRecentShortUrl</span> <span class="o">=</span> <span class="nx">shortUrls</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="kd">var</span> <span class="nx">responseBody</span> <span class="o">=</span> <span class="nx">httpGet</span><span class="p">(</span><span class="nx">expandUrlUsingTwitterApi</span><span class="p">(</span><span class="nx">mostRecentShortUrl</span><span class="p">));</span> <span class="c1">// blocking x 2</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Most recent link text:&quot;</span><span class="p">,</span> <span class="nx">responseBody</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s2">&quot;Error with the twitterverse: &quot;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Note in particular how errors flowed from any step in the process to our <code>catch</code> handler, without explicit by-hand
bubbling code. And with the upcoming ECMAScript 6 revision of JavaScript, plus some <a href="http://taskjs.org/">party tricks</a>, the code becomes
not only parallel but almost identical.</p>

<h2 id="that-second-paragraph">That Second Paragraph</h2>

<p>All of this is essentially enabled by that second paragraph:</p>

<blockquote>
<p>This function should return a new promise that is fulfilled when the given <code>fulfilledHandler</code> or <code>errorHandler</code>
callback is finished. This allows promise operations to be chained together. The value returned from the callback
handler is the fulfillment value for the returned promise. If the callback throws an error, the returned promise will
be moved to failed state.</p>
</blockquote>

<p>In other words, <code>then</code> is <em>not</em> a mechanism for attaching callbacks to an aggregate collection. It&rsquo;s a mechanism for
<em>applying a transformation</em> to a promise, and yielding a <em>new</em> promise from that transformation.</p>

<p>This explains the crucial first phrase: &ldquo;this function should return a new promise.&rdquo; Libraries like jQuery (before 1.8)
don&rsquo;t do this: they simply mutate the state of the existing promise. That means if you give a promise out to multiple
consumers, they can interfere with its state. To realize how ridiculous that is, consider the synchronous parallel: if
you gave out a function&rsquo;s return value to two people, and one of them could somehow change it into a thrown exception!
Indeed, Promises/A points this out explicitly:</p>

<blockquote>
<p>Once a promise is fulfilled or failed, the promise&rsquo;s value MUST not be changed, just as a values in JavaScript,
primitives and object identities, can not change (although objects themselves may always be mutable even if their
identity isn&rsquo;t).</p>
</blockquote>

<p>Now consider the last two sentences. They inform how this new promise is created. In short:</p>

<ul>
<li>If either handler returns a value, the new promise is fulfilled with that value.</li>
<li>If either handler throws an exception, the new promise is rejected with that exception.</li>
</ul>

<p>This breaks down into four scenarios, depending on the state of the promise. Here we give their synchronous parallels so
you can see why it&rsquo;s crucially important to have semantics for all four:</p>

<ol>
<li>Fulfilled, fulfillment handler returns a value: simple functional transformation</li>
<li>Fulfilled, fulfillment handler throws an exception: getting data, and throwing an exception in response to it</li>
<li>Rejected, rejection handler returns a value: a <code>catch</code> clause got the error and handled it</li>
<li>Rejected, rejection handler throws an exception: a <code>catch</code> clause got the error and re-threw it (or a new one)</li>
</ol>

<p>Without these transformations being applied, you lose all the power of the synchronous/asynchronous parallel, and your
so-called &ldquo;promises&rdquo; become simple callback aggregators. This is the problem with jQuery&rsquo;s current &ldquo;promises&rdquo;: they only
support scenario 1 above, omitting entirely support for scenarios 2–4. This was also the problem with Node.js 0.1&rsquo;s
<code>EventEmitter</code>-based &ldquo;promises&rdquo; (which weren&rsquo;t even <code>then</code>able).</p>

<p>Furthermore, note that by catching exceptions and transforming them into rejections, we take care of both intentional
and unintentional exceptions, just like in sync code. That is, if you write <code>aFunctionThatDoesNotExist()</code> in either
handler, your promise becomes rejected and that error will bubble up the chain to the nearest rejection handler just as
if you had written <code>throw new Error(&quot;bad data&quot;)</code>. Look ma, no domains!</p>

<h2 id="so-what?">So What?</h2>

<p>Maybe you&rsquo;re breathlessly taken by my inexorable logic and explanatory powers. More likely, you&rsquo;re asking yourself why
this guy is raging so hard over some poorly-behaved libraries.</p>

<p>Here&rsquo;s the problem:</p>

<blockquote>
<p>A promise is defined as an object that has a function as the value for the property <code>then</code></p>
</blockquote>

<p>As authors of Promises/A-consuming libraries, we would like to assume this statement to be true: that something that
is &ldquo;thenable&rdquo; actually behaves as a Promises/A promise, with all the power that entails.</p>

<p>If you can make this assumption, you can write <a href="https://github.com/domenic/chai-as-promised/">very extensive libraries</a> that are entirely agnostic
to the implementation of the promises they accept! Whether they be from <a href="https://github.com/kriskowal/q">Q</a>, <a href="https://github.com/cujojs/when">when.js</a>, or even <a href="http://msdn.microsoft.com/en-us/library/windows/apps/br211867.aspx">WinJS</a>, you can
use the simple composition rules of the Promises/A spec to build on promise behavior. For example, here&rsquo;s a generalized
<a href="https://gist.github.com/2936696">retry function</a> that works with any Promises/A implementation.</p>

<p>Unfortunately, libraries like jQuery break this. This necessitates <a href="https://github.com/domenic/chai-as-promised/blob/4bc1d6b217acde85c8af56dc3cd09f05bb752549/lib/chai-as-promised.js#L28-30">ugly hacks</a> to detect the presence of objects
masquerading as promises, and who call themselves in their API documentation promises, but aren&rsquo;t really Promises/A
promises. If the consumers of your API start trying to pass you jQuery promises, you have two choices: fail in
mysterious and hard-to-decipher ways when your compositional techniques fail, or fail up-front and block them from using
your library entirely. This sucks.</p>

<h2 id="the-way-forward">The Way Forward</h2>

<p>So this is why I want to avoid an unfortunate <a href="https://github.com/emberjs/ember.js/commit/f7ac080db3a2a15f5814dc26fc86712cf7d252c8">callback aggregator solution</a> ending up in Ember. That&rsquo;s why I
wrote this essay. And that&rsquo;s why, in the hours following writing the original version of this essay, I worked up
<a href="https://github.com/domenic/promise-tests">a general Promises/A compliance suite</a> that we can all use to get on the same page in the future.</p>

<p>Since the release of that test suite, great progress has been made in promise interoperability and understanding. One
library, <a href="https://github.com/tildeio/rsvp.js">rsvp.js</a>, was released with the explicit goal of providing these features of Promises/A. Others
<a href="https://twitter.com/wookiehangover/status/258641272913412096">followed suit</a>. But the most exciting result was the formation of the <a href="https://github.com/promises-aplus">Promises/A+ organization</a>,
a loose coalition of implementors who have produced the <a href="http://promises-aplus.github.com/promises-spec/">Promises/A+ specification</a> extending and
clarifying the prose of the original Promises/A spec into something unambiguous and <a href="https://github.com/promises-aplus/promises-tests">well-tested</a>.</p>

<p>There&rsquo;s still work to be done, of course. Notably, at current time of writing, the latest jQuery version is 1.9.1, and
its promises implementation is completely broken with regard to the error handling semantics. Hopefully, with the above
explanation to set the stage and the Promises/A+ spec and test suite in place, this problem can be corrected in jQuery
2.0.</p>

<p>In the meantime, here are the libraries that conform to Promises/A+, and that I can thus unreservedly recommend:</p>

<ul>
<li><a href="https://github.com/kriskowal/q">Q</a> by Kris Kowal and myself: a full-featured promise library with a large, powerful API surface, adapters for
Node.js, progress support, and preliminary support for long stack traces.</li>
<li><a href="https://github.com/tildeio/rsvp.js">RSVP.js</a> by Yehuda Katz: a very small and lightweight, but still fully compliant, promise library.</li>
<li><a href="https://github.com/cujojs/when">when.js</a> by Brian Cavalier: an intermediate library with utilities for managing collections of eventual tasks,
as well as support for both progress and cancellation.</li>
</ul>

<p>If you are stuck with a crippled &ldquo;promise&rdquo; from a source like jQuery, I recommend using one of the above libraries&#39;
assimilation utilities (usually under the name <code>when</code>) to convert to a real promise as soon as possible. For example:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nx">Q</span><span class="p">.</span><span class="nx">when</span><span class="p">(</span><span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">&quot;https://github.com/kriskowal/q&quot;</span><span class="p">));</span>
<span class="c1">// aaaah, much better</span>
</code></pre></div>]]></content>
  </entry>
  
</feed>
